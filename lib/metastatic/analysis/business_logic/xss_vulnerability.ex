defmodule Metastatic.Analysis.BusinessLogic.XSSVulnerability do
  @moduledoc """
  Detects potential Cross-Site Scripting (XSS) vulnerabilities (CWE-79).

  This analyzer identifies code patterns where user input is rendered in HTML
  output without proper escaping, which can lead to XSS attacks.

  ## Cross-Language Applicability

  XSS is a **universal web vulnerability** affecting all web frameworks:

  - **Elixir/Phoenix**: `raw(user_input)`, `{:safe, user_input}`
  - **Python/Django**: `mark_safe(user_input)`, `|safe` filter
  - **Python/Flask**: `Markup(user_input)`, `|safe` filter
  - **JavaScript/React**: `dangerouslySetInnerHTML={{__html: userInput}}`
  - **JavaScript/Vue**: `v-html="userInput"`
  - **JavaScript/Angular**: `[innerHTML]="userInput"`
  - **Ruby/Rails**: `raw(user_input)`, `html_safe`
  - **PHP**: Direct `echo $user_input` without htmlspecialchars
  - **Java/JSP**: `<%= userInput %>` without escaping

  ## Problem

  When user-controlled data is rendered in HTML without escaping:
  - Attackers can inject malicious JavaScript
  - Can steal session cookies and credentials
  - Can perform actions on behalf of users
  - Can deface websites or redirect users

  ## Detection Strategy

  Detects patterns where:
  1. `raw()`, `mark_safe()`, `html_safe`, or similar functions are used
  2. `innerHTML`, `dangerouslySetInnerHTML`, `v-html` patterns appear
  3. User input flows directly to HTML output without sanitization

  ## Examples

  ### Bad (Elixir/Phoenix)

      def show(conn, %{"name" => name}) do
        html = "<h1>Hello, \#{name}</h1>"
        render(conn, "page.html", content: raw(html))
      end

  ### Good (Elixir/Phoenix)

      def show(conn, %{"name" => name}) do
        render(conn, "page.html", name: name)  # Auto-escaped in template
      end

  ### Bad (JavaScript/React)

      function Welcome({name}) {
        return <div dangerouslySetInnerHTML={{__html: name}} />;
      }

  ### Good (JavaScript/React)

      function Welcome({name}) {
        return <div>{name}</div>;  // Auto-escaped
      }
  """

  @behaviour Metastatic.Analysis.Analyzer

  alias Metastatic.Analysis.Analyzer

  @unsafe_html_functions ~w[
    raw html_safe mark_safe safe_concat
    Markup SafeString unescape_html
    dangerouslySetInnerHTML innerHTML
    v-html ng-bind-html trustAsHtml
    bypass_sanitize
  ]

  @user_input_indicators ~w[
    params request args query body
    input user session cookie form
    get post put patch delete
  ]

  @impl true
  def info do
    %{
      name: :xss_vulnerability,
      category: :security,
      description: "Detects potential Cross-Site Scripting (XSS) vulnerabilities (CWE-79)",
      severity: :error,
      explanation: """
      Cross-Site Scripting (XSS) occurs when user input is rendered in HTML output
      without proper escaping. This allows attackers to:
      - Inject malicious JavaScript into web pages
      - Steal session cookies and user credentials
      - Perform actions on behalf of authenticated users
      - Redirect users to malicious websites

      Always escape user input before rendering in HTML, or use framework-provided
      auto-escaping mechanisms.
      """,
      configurable: true
    }
  end

  @impl true
  # Detect calls to unsafe HTML functions
  def analyze({:function_call, meta, args} = node, context) when is_list(meta) do
    func_name = Keyword.get(meta, :name, "")

    cond do
      is_unsafe_html_function?(func_name) ->
        check_unsafe_html_call(node, func_name, args, context)

      is_render_function?(func_name) and has_raw_content?(args) ->
        [create_xss_issue(node, "Render function called with raw/unescaped content")]

      true ->
        []
    end
  end

  # Detect attribute assignments like innerHTML
  def analyze({:assignment, _meta, [target, value]} = node, context) when is_tuple(target) do
    case target do
      {:attribute_access, _, [_obj, attr]} when is_binary(attr) ->
        if String.downcase(attr) in ["innerhtml", "outerhtml"] do
          if contains_user_input?(value, context) do
            [create_xss_issue(node, "innerHTML assigned with potentially user-controlled value")]
          else
            [create_xss_issue(node, "innerHTML assignment detected - ensure value is sanitized")]
          end
        else
          []
        end

      _ ->
        []
    end
  end

  # Detect tuple patterns like {:safe, user_input} in Elixir
  def analyze({:tuple, _meta, elements} = node, context) when is_list(elements) do
    case elements do
      [{:literal, _, :safe}, value] ->
        if contains_user_input?(value, context) do
          [create_xss_issue(node, "{:safe, ...} tuple with potentially user-controlled content")]
        else
          []
        end

      _ ->
        []
    end
  end

  def analyze(_node, _context), do: []

  # ----- Private Helpers -----

  defp check_unsafe_html_call(node, func_name, args, context) do
    if args_contain_user_input?(args, context) do
      [
        Analyzer.issue(
          analyzer: __MODULE__,
          category: :security,
          severity: :error,
          message: "Potential XSS: '#{func_name}' called with user-controlled input",
          node: node,
          metadata: %{
            cwe: 79,
            function: func_name,
            suggestion: "Sanitize user input before marking as safe, or use auto-escaping"
          }
        )
      ]
    else
      [
        Analyzer.issue(
          analyzer: __MODULE__,
          category: :security,
          severity: :warning,
          message:
            "Potential XSS: '#{func_name}' bypasses HTML escaping - ensure input is trusted",
          node: node,
          metadata: %{
            cwe: 79,
            function: func_name,
            suggestion: "Review usage to ensure no user input can reach this code path"
          }
        )
      ]
    end
  end

  defp create_xss_issue(node, message) do
    Analyzer.issue(
      analyzer: __MODULE__,
      category: :security,
      severity: :error,
      message: "Potential XSS: #{message}",
      node: node,
      metadata: %{
        cwe: 79,
        suggestion: "Escape user input before rendering in HTML"
      }
    )
  end

  defp is_unsafe_html_function?(func_name) when is_binary(func_name) do
    func_lower = String.downcase(func_name)

    Enum.any?(@unsafe_html_functions, fn pattern ->
      String.contains?(func_lower, String.downcase(pattern))
    end)
  end

  defp is_unsafe_html_function?(_), do: false

  defp is_render_function?(func_name) when is_binary(func_name) do
    func_lower = String.downcase(func_name)

    String.contains?(func_lower, "render") or
      String.contains?(func_lower, "html") or
      String.contains?(func_lower, "template")
  end

  defp is_render_function?(_), do: false

  defp has_raw_content?(args) when is_list(args) do
    Enum.any?(args, fn arg ->
      case arg do
        {:function_call, meta, _} when is_list(meta) ->
          func_name = Keyword.get(meta, :name, "")
          is_unsafe_html_function?(func_name)

        {:tuple, _, [{:literal, _, :safe}, _]} ->
          true

        _ ->
          false
      end
    end)
  end

  defp has_raw_content?(_), do: false

  defp args_contain_user_input?(args, context) when is_list(args) do
    Enum.any?(args, &contains_user_input?(&1, context))
  end

  defp args_contain_user_input?(_, _), do: false

  defp contains_user_input?(node, context) do
    case node do
      {:variable, _meta, name} when is_binary(name) ->
        is_user_input_variable?(name) or in_user_input_scope?(name, context)

      {:function_call, meta, _args} when is_list(meta) ->
        func_name = Keyword.get(meta, :name, "")
        is_user_input_function?(func_name)

      {:attribute_access, _meta, children} when is_list(children) ->
        Enum.any?(children, &contains_user_input?(&1, context))

      {:binary_op, _meta, [left, right]} ->
        contains_user_input?(left, context) or contains_user_input?(right, context)

      {:map, _meta, pairs} when is_list(pairs) ->
        Enum.any?(pairs, fn
          {_k, v} -> contains_user_input?(v, context)
          _ -> false
        end)

      _ ->
        false
    end
  end

  defp is_user_input_variable?(name) when is_binary(name) do
    name_lower = String.downcase(name)
    Enum.any?(@user_input_indicators, &String.contains?(name_lower, &1))
  end

  defp is_user_input_function?(func_name) when is_binary(func_name) do
    func_lower = String.downcase(func_name)
    Enum.any?(@user_input_indicators, &String.contains?(func_lower, &1))
  end

  defp is_user_input_function?(_), do: false

  defp in_user_input_scope?(name, context) do
    # Check if we're in a controller action or request handler context
    fn_name = Map.get(context, :function_name, "")
    params = Map.get(context, :params, [])

    name in params or
      String.contains?(String.downcase(fn_name), ["action", "handler", "controller"])
  end
end

defmodule Metastatic.Analysis.BusinessLogic.SSRFVulnerability do
  @moduledoc """
  Detects potential Server-Side Request Forgery (SSRF) vulnerabilities (CWE-918).

  This analyzer identifies code patterns where user-controlled input is used to
  construct URLs that are then fetched by the server, potentially allowing
  attackers to access internal resources.

  ## Cross-Language Applicability

  SSRF is a **universal web vulnerability**:

  - **Elixir**: `HTTPoison.get(params["url"])`
  - **Python**: `requests.get(request.args.get('url'))`
  - **JavaScript/Node**: `axios.get(req.body.url)`
  - **Ruby**: `Net::HTTP.get(URI(params[:url]))`
  - **PHP**: `file_get_contents($_GET['url'])`
  - **Java**: `new URL(request.getParameter("url")).openStream()`
  - **C#**: `WebClient.DownloadString(Request.QueryString["url"])`
  - **Go**: `http.Get(r.FormValue("url"))`

  ## Problem

  When URLs are constructed from user input without validation:
  - Attackers can make the server request internal resources
  - Can scan internal networks and services
  - Can access cloud metadata endpoints (169.254.169.254)
  - Can bypass firewall restrictions
  - Can exfiltrate sensitive data

  ## Detection Strategy

  Detects patterns where:
  1. HTTP client functions receive user-controlled URLs
  2. URL construction concatenates user input
  3. No URL validation/allowlisting is apparent

  ## Examples

  ### Bad (Elixir)

      def fetch(conn, %{"url" => url}) do
        {:ok, response} = HTTPoison.get(url)
        json(conn, %{content: response.body})
      end

  ### Good (Elixir)

      @allowed_domains ["api.example.com", "cdn.example.com"]

      def fetch(conn, %{"url" => url}) do
        uri = URI.parse(url)

        if uri.host in @allowed_domains and uri.scheme == "https" do
          {:ok, response} = HTTPoison.get(url)
          json(conn, %{content: response.body})
        else
          conn |> put_status(400) |> json(%{error: "Invalid URL"})
        end
      end
  """

  @behaviour Metastatic.Analysis.Analyzer

  alias Metastatic.Analysis.Analyzer
  alias Metastatic.Semantic.OpKind

  @http_client_functions ~w[
    get post put patch delete head options
    request fetch send
    HTTPoison.get HTTPoison.post HTTPoison.request
    Req.get Req.post Req.request
    Tesla.get Tesla.post Tesla.request
    Finch.request Finch.build
    requests.get requests.post urllib.request.urlopen
    axios.get axios.post fetch http.get
    Net::HTTP.get RestClient.get Faraday.get
    HttpClient.GetAsync WebClient.DownloadString
    http.Get http.Post
    file_get_contents curl_exec
  ]

  @url_construction_functions ~w[
    URI.parse URL URI
    new_url build_url construct_url
    url_for
  ]

  @user_input_patterns ~w[
    params request args query body
    input url uri link href
    target endpoint host domain
    callback webhook redirect
  ]

  @impl true
  def info do
    %{
      name: :ssrf_vulnerability,
      category: :security,
      description:
        "Detects potential Server-Side Request Forgery (SSRF) vulnerabilities (CWE-918)",
      severity: :error,
      explanation: """
      Server-Side Request Forgery (SSRF) occurs when user input controls the destination
      of server-side HTTP requests. This allows attackers to:
      - Access internal services (databases, admin panels)
      - Scan internal networks
      - Access cloud metadata endpoints (169.254.169.254)
      - Bypass firewalls and access controls

      Always validate URLs before making requests:
      - Use allowlists for permitted domains
      - Block private IP ranges and localhost
      - Validate URL scheme (https only)
      - Use URL parsing to extract and validate components
      """,
      configurable: true
    }
  end

  @impl true
  # Detect HTTP client calls with user-controlled URLs
  def analyze({:function_call, meta, args} = node, context) when is_list(meta) do
    func_name = Keyword.get(meta, :name, "")
    op_kind = Keyword.get(meta, :op_kind)

    cond do
      # Semantic detection via op_kind
      is_list(op_kind) and OpKind.http?(op_kind) and has_user_controlled_url?(args, context) ->
        [create_ssrf_issue(node, func_name, "HTTP request with user-controlled URL")]

      # Heuristic detection
      is_http_function?(func_name) and has_user_controlled_url?(args, context) ->
        [create_ssrf_issue(node, func_name, "HTTP request with user-controlled URL")]

      # URL construction with user input
      is_url_function?(func_name) and has_user_input_argument?(args, context) ->
        [
          Analyzer.issue(
            analyzer: __MODULE__,
            category: :security,
            severity: :warning,
            message: "Potential SSRF: URL constructed from user input in '#{func_name}'",
            node: node,
            metadata: %{
              cwe: 918,
              function: func_name,
              suggestion: "Validate URL against allowlist before use"
            }
          )
        ]

      true ->
        []
    end
  end

  # Detect URL concatenation patterns
  def analyze({:binary_op, meta, [left, right]} = node, context) when is_list(meta) do
    operator = Keyword.get(meta, :operator)

    if operator in [:concat, :<>, :+] do
      cond do
        looks_like_url?(left) and contains_user_input?(right, context) ->
          [create_ssrf_issue(node, "concatenation", "URL concatenation with user input")]

        looks_like_url?(right) and contains_user_input?(left, context) ->
          [create_ssrf_issue(node, "concatenation", "User input concatenated with URL")]

        true ->
          []
      end
    else
      []
    end
  end

  def analyze(_node, _context), do: []

  # ----- Private Helpers -----

  defp create_ssrf_issue(node, func_name, description) do
    Analyzer.issue(
      analyzer: __MODULE__,
      category: :security,
      severity: :error,
      message: "Potential SSRF: #{description} in '#{func_name}'",
      node: node,
      metadata: %{
        cwe: 918,
        function: func_name,
        suggestion: "Validate URL against allowlist of permitted domains"
      }
    )
  end

  defp is_http_function?(func_name) when is_binary(func_name) do
    func_lower = String.downcase(func_name)

    Enum.any?(@http_client_functions, fn pattern ->
      String.contains?(func_lower, String.downcase(pattern))
    end)
  end

  defp is_http_function?(_), do: false

  defp is_url_function?(func_name) when is_binary(func_name) do
    func_lower = String.downcase(func_name)

    Enum.any?(@url_construction_functions, fn pattern ->
      String.contains?(func_lower, String.downcase(pattern))
    end)
  end

  defp is_url_function?(_), do: false

  defp has_user_controlled_url?(args, context) when is_list(args) do
    # First argument is usually the URL
    case args do
      [first | _] -> contains_user_input?(first, context)
      _ -> false
    end
  end

  defp has_user_controlled_url?(_, _), do: false

  defp has_user_input_argument?(args, context) when is_list(args) do
    Enum.any?(args, &contains_user_input?(&1, context))
  end

  defp has_user_input_argument?(_, _), do: false

  defp contains_user_input?(node, context) do
    case node do
      {:variable, _meta, name} when is_binary(name) ->
        is_user_input_variable?(name) or in_tainted_scope?(name, context)

      {:function_call, meta, _args} when is_list(meta) ->
        func_name = Keyword.get(meta, :name, "")
        is_user_input_function?(func_name)

      {:attribute_access, _meta, children} when is_list(children) ->
        Enum.any?(children, &contains_user_input?(&1, context))

      {:binary_op, _meta, [left, right]} ->
        contains_user_input?(left, context) or contains_user_input?(right, context)

      {:map_access, _meta, [map, _key]} ->
        contains_user_input?(map, context)

      _ ->
        false
    end
  end

  defp is_user_input_variable?(name) when is_binary(name) do
    name_lower = String.downcase(name)
    Enum.any?(@user_input_patterns, &String.contains?(name_lower, &1))
  end

  defp is_user_input_function?(func_name) when is_binary(func_name) do
    func_lower = String.downcase(func_name)
    Enum.any?(@user_input_patterns, &String.contains?(func_lower, &1))
  end

  defp is_user_input_function?(_), do: false

  defp in_tainted_scope?(name, context) do
    tainted_vars = Map.get(context, :tainted_vars, MapSet.new())
    MapSet.member?(tainted_vars, name)
  end

  defp looks_like_url?({:literal, meta, value}) when is_list(meta) and is_binary(value) do
    String.starts_with?(value, "http://") or
      String.starts_with?(value, "https://") or
      String.starts_with?(value, "//") or
      String.contains?(value, "://")
  end

  defp looks_like_url?({:variable, _meta, name}) when is_binary(name) do
    name_lower = String.downcase(name)

    String.contains?(name_lower, "url") or
      String.contains?(name_lower, "uri") or
      String.contains?(name_lower, "endpoint") or
      String.contains?(name_lower, "host")
  end

  defp looks_like_url?(_), do: false
end
